from enum import Enum

# This file is generated from meta.py.in

class Status(Enum):
    CURRENT = 0
    DEPRECATED = 1
    OBSOLETE = 2

{{ range $index, $def := .MetaDefs}}
{{ if $def.IsMetaDef }}
class {{ .Name }}():
    __slots__ = [
        "parent",
{{- if eq $def.Name "Module" }}
        "hnd",
        '__weakref__',
{{- end }}
{{- range $def.Fields }}
        "{{.PyName}}",
{{- end }}
    ]
{{- end }}

    {{- if eq $def.Name "List" }}
    def keyMeta(self):
        keyMeta = []
        for keyName in self.keys:
            keyMeta.append(require_def(self, keyName))
        return keyMeta
    {{- end }}

{{- end }}

class Path():

    def __init__(self, parent, meta, key=None):
        self.parent = parent
        self.meta = meta
        self.key = key

    def str(self):
        s = self.meta.ident
        if self.key != None:
            s = f'{s}({",".join(self.key)})'
        if self.parent:
            return self.parent.str() + '/' + s
        return s

def new_path(module, path_str):
    """Construct a path object from a module and child-ident/grand-child-ident/..."""
    segs = path_str.split('/')
    path = Path(None, module)
    for seg in segs:
        found = get_def(path.meta, seg)
        if not found:
            return None
        path = Path(path, found)
    return path

def get_def(meta, ident):
    if hasattr(meta, 'definitions'):
        for ddef in meta.definitions:
            if ddef.ident == ident:
                return ddef

    if hasattr(meta, 'actions'):
        ddef = meta.actions.get(ident, None)
        if ddef:
            return ddef

    if hasattr(meta, 'notifications'):
        ddef = meta.notifications.get(ident, None)
        if ddef:
            return ddef

    return None

def require_def(meta, ident):
    if not meta:
        raise Exception(f'no meta given to find {ident}')
    ddef = get_def(meta, ident)
    if ddef:
        return ddef
    raise Exception(f'definition {ident} not found in {meta.ident}')



