from enum import IntEnum
from freeconf.pb import val_pb2
from pprint import pprint

class Format(IntEnum):
{{- range .ValEnums }}
    {{.Ident}} = {{.Value}}
{{- end }}

class Val():
    
    def __init__(self, v, format=None):
        """
        param: format: Go side will coerse values to the required format if it it possible 
            so in most cases you can return values that are close enough to the YANG.
        """
        self.v = v
        if format is None:
            self.format = Val.auto_pick_format(v)
        else:
            self.format = format

    @classmethod
    def auto_pick_format(cls, v):
        t = type(v)
        if t is list:
            if len(v) > 0:
                return Val.auto_pick_format(v[0]) + 1024
            else: # if empty, doesn't really matter
                return Format.STRING_LIST
        if t is int:
            return Format.INT32
        if t is float:
            return Format.DECIMAL64
        if t is bool:
            return Format.BOOL
        if t is str:
            return Format.STRING
        raise Exception(f"could not auto pick format for {v} with type {type(v)}")        

def proto_encode(val):
    if val == None:
        return None
{{- range .ValEnums }}
    if val.format == Format.{{.Ident}}:
  {{- if .IsList }}
        vals = []
        for x_val in val.v:
            vals.append(val_pb2.ValUnion({{.PyNonListIdent}}_val=x_val))
        return val_pb2.Val(format=val_pb2.{{.Ident}}, list_value=vals)
  {{- else }}
        return val_pb2.Val(format=val_pb2.{{.Ident}}, value=val_pb2.ValUnion({{.PyNonListIdent}}_val=val.v))
  {{- end }}
{{- end }}
    raise Exception(f'unimplemented value encoder {val.format}')


def proto_decode(proto_val):
    if proto_val == None:
        return None
{{- range .ValEnums }}
    if proto_val.format == val_pb2.{{.Ident}}:
  {{- if .IsList }}
        vals = []
        for p_val in proto_val.list_value:
            vals.append(p_val.{{.PyNonListIdent}}_val)
        return Val(vals, Format.{{.Ident}})
  {{- else }}
        return Val(proto_val.value.{{.PyNonListIdent}}_val, Format.{{.Ident}})
  {{- end }}
{{- end }}
    raise Exception(f'unimplemented list value decoder {pprint(proto_val)}')
