#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <cbor.h>

#include "freeconf.h"

// forward declations for circular calls
fc_pack_err unpack_fc_meta_array(fc_meta_array* defs, fc_meta* parent, cbor_item_t *item);
fc_pack_err unpack_fc_meta_extension_ptr(fc_meta_extension** ext, fc_meta* parent, cbor_item_t* item);

fc_pack_err unpack_expect(cbor_item_t* item, int expected)  {
    if (cbor_typeof(item) != expected) {
        printf("expected %d but got %d\n", expected, cbor_typeof(item));
        return FC_UNEXPECTED_ENCODING;
    }    
    return FC_ERR_NONE;
}

fc_pack_err unpack_long(long *l, fc_meta* parent, cbor_item_t *item) {
    *l = (long)cbor_get_uint64(item);
    return FC_ERR_NONE;
}

fc_pack_err unpack_char_ptr(char **s, fc_meta* parent, cbor_item_t *item) {
    char *src = (char *)cbor_string_handle(item);
    size_t len = cbor_string_length(item);
    *s = (char *)malloc(len + 1);
    memcpy(*s, src, len);
    (*s)[len] = 0;
    return FC_ERR_NONE;
}

fc_pack_err unpack_char_ptr_ptr(char ***strs_ptr, fc_meta* parent, cbor_item_t *item) {
    fc_pack_err err = unpack_expect(item, CBOR_TYPE_ARRAY);
    if (err != FC_ERR_NONE) {
        return err;
    }

    size_t len = cbor_array_size(item);    
    (*strs_ptr) = (char **)malloc(len * sizeof(char*));
    char** strs = (*strs_ptr);
    cbor_item_t** array = cbor_array_handle(item);
    for (int i = 0; i < len; i++) {
        err = unpack_char_ptr(&(strs[i]), NULL, array[i]);
        if (err != FC_ERR_NONE) {
            return err;
        }
    }

    return FC_ERR_NONE;
}

fc_pack_err unpack_bool(bool* b, fc_meta* parent, cbor_item_t *item) {
    *b = cbor_get_bool(item);
    return FC_ERR_NONE;
}

fc_pack_err unpack_int(int* i, fc_meta* parent, cbor_item_t *item) {
    *i = (int)cbor_get_uint32(item);
    return FC_ERR_NONE;
}

fc_pack_err unpack_fc_meta_id(fc_meta_id *t, fc_meta* parent, cbor_item_t *item) {
    *t = (fc_meta_id)cbor_get_uint32(item);
    return FC_ERR_NONE;
}

fc_pack_err unpack_fc_meta_optional_bool(fc_meta_optional_bool *b, fc_meta* parent, cbor_item_t *item) {
    *b = (fc_meta_optional_bool)cbor_get_uint32(item);
    return FC_ERR_NONE;
}

fc_pack_err unpack_fc_meta_ext_array(fc_meta_ext_array* exts, fc_meta* parent, cbor_item_t *item) {
    fc_pack_err err = unpack_expect(item, CBOR_TYPE_ARRAY);
    if (err != FC_ERR_NONE) {
        return err;
    }

    size_t len = cbor_array_size(item);
    exts->length = len;
    exts->extensions = (fc_meta_extension**)malloc(len * sizeof(fc_meta_extension*));
    cbor_item_t** array = cbor_array_handle(item);
    for (int i = 0; i < len; i++) {
        err = unpack_fc_meta_extension_ptr(&(exts->extensions[i]), parent, array[i]);
        if (err != FC_ERR_NONE) {
            return err;
        }
    }

    return FC_ERR_NONE;
}

fc_pack_err unpack_fc_meta_ext_def_arg_array(fc_meta_ext_def_arg_array* args, fc_meta* parent, cbor_item_t *item) {
    return FC_NOT_IMPLEMENTED;
}

{{ range .Meta.Definitions }}
fc_pack_err unpack_{{. | cDefType }}_ptr({{. | cDefType }}** def, fc_meta* parent, cbor_item_t* item) {
    fc_pack_err err = unpack_expect(item, CBOR_TYPE_ARRAY);
    if (err != FC_ERR_NONE) {
        return err;
    }
    *def = calloc(1, sizeof({{. | cDefType }}));    
    {{. | cDefType }}* def_ptr = *def;
    def_ptr->parent = parent;
    fc_meta* meta = (fc_meta*)*def;
    cbor_item_t** array = cbor_array_handle(item);
    {{- range $index, $field := .Fields }}
    err = unpack_{{$field | cFieldType | cNameSafe }}(&(def_ptr->{{ $field | cName }}), meta, array[{{ $index }}]);
    if (err != FC_ERR_NONE) {
        return err;
    }
    {{- end }}

    return FC_ERR_NONE;
}
{{ end }}

fc_pack_err unpack_fc_meta_array(fc_meta_array* defs, fc_meta* parent, cbor_item_t *item) {
    fc_pack_err err = unpack_expect(item, CBOR_TYPE_ARRAY);
    if (err != FC_ERR_NONE) {
        return err;
    }
    size_t len = cbor_array_size(item);
    defs->metas = (fc_meta**)malloc(len * sizeof(fc_meta*));
    defs->length = len;
    cbor_item_t** array = cbor_array_handle(item);
    for (int i = 0; i < len; i++) {
        cbor_item_t** next = cbor_array_handle(array[i]);
        fc_meta_id next_type;
        fc_meta** next_meta = &(defs->metas[i]);
        err = unpack_fc_meta_id(&next_type, parent, next[0]);
        if (err != FC_ERR_NONE) {
            return err;
        }
        switch (next_type) {
            {{ range .Meta.Definitions }}
            case FC_{{ .Name | snake| uc -}}: {
                {{. | cDefType }}** def = ({{. | cDefType }}**)(next_meta);
                err = unpack_{{. | cDefType }}_ptr(def, parent, array[i]);
                break;
            }
            {{ end }}
            default:
                return FC_NOT_IMPLEMENTED;
        }
        if (err != FC_ERR_NONE) {
            return err;
        }
    }

    return FC_ERR_NONE;
}

fc_pack_err fc_unpack_fc_meta(fc_meta_module** m, void* buffer, int len) {
    struct cbor_load_result result;
    cbor_item_t* item = cbor_load(buffer, len, &result);
    if (item == NULL) {
        if (result.error.code != CBOR_ERR_NONE) {
            return FC_BAD_ENCODING;
        }
        return FC_EMPTY_BUFFER;
    }
    //cbor_describe(item, stdout);
    fc_pack_err err = unpack_fc_meta_module_ptr(m, NULL, item);
    cbor_decref(&item);
    return err;
}
